

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lee">
  <meta name="keywords" content="">
  
    <meta name="description" content="读写文件，控制台交互，这是C&#x2F;C++永恒的主题之一。">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++：关于文件I&#x2F;O">
<meta property="og:url" content="http://example.com/2021/08/07/c_cpp_about_file_io/index.html">
<meta property="og:site_name" content="Lee&#39;s blog">
<meta property="og:description" content="读写文件，控制台交互，这是C&#x2F;C++永恒的主题之一。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/index_imgs/c_cpp_about_file_io.jpg">
<meta property="article:published_time" content="2021-08-07T09:16:08.000Z">
<meta property="article:modified_time" content="2022-10-08T02:11:59.606Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/index_imgs/c_cpp_about_file_io.jpg">
  
  
  
  <title>C/C++：关于文件I/O - Lee&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/index_imgs/c_cpp_about_file_io.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">C/C++：关于文件I/O</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-08-07 17:16" pubdate>
          2021年8月7日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          81 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C/C++：关于文件I/O</h1>
            
            
              <div class="markdown-body">
                
                <p>读写文件，控制台交互，这是C/C++永恒的主题之一。</p>
<span id="more"></span>

<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>每个人都知道至少一种输入、输出的编写方式。如果你是一个基础扎实的编码者，或许你知道两种甚至更多。这对于编写自己的程序似乎是远远足够了。</p>
<p>但在上周，在我查询关于如何在C/C++里实现<code>$ ls -a | grep txt</code>时，我遇到了一些挫折。如你所见，这里需要一些重定向和管道的知识。我查到了许多有效的代码案例，但让我困惑的是，它们的风格并不一致，有的使用了<code>fopen()</code>，有的使用了<code>dup()</code>，有的使用<code>printf()</code>，有的使用<code>write()</code>。我确信其中的相当一部分是可以彼此替代的，但却无从下手。</p>
<p>因此，我重新梳理了以下关于文件I/O的一些核心命题。你恐怕不会读到太多时髦的东西，但我相信这些知识能帮你更好地理解一些已经存在了很久的东西。</p>
<p>在下文，我试图回答以下几个问题：</p>
<ol>
<li>什么是文件描述符（为什么这个非负整数可以代表一个文件）</li>
<li>用文件描述符管理文件，和用文件指针有什么区别</li>
<li>什么是系统I/O和标准I/O（你用过<code>dup()</code>吗）</li>
<li>为什么不要混合使用系统I/O和标准I/O</li>
<li>缓冲区会搞出什么乱子（C/C++给我上的第一课：最简单的功能需要最深刻的理解）</li>
<li>标准输入/输出/错误是什么（是键盘输入、屏幕输出）</li>
<li>怎么在C/C++里面重定向标准流输入/输出（我知道，很多作业需要这个）</li>
</ol>
<p>现在，让我们从这一行代码开始吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br></code></pre></td></tr></table></figure>


<h2 id="打开文件表-open-file-table"><a href="#打开文件表-open-file-table" class="headerlink" title="打开文件表(open file table)"></a>打开文件表(open file table)</h2><p>为了理解文件描述符(file descriptor)的概念，让我们先回顾一下操作系统和文件系统(Virtual File System, VFS)的内容。</p>
<p><img src="/2021/08/07/c_cpp_about_file_io/1628407713527.png" srcset="/img/loading.gif" lazyload></p>
<p>我们知道，文件存储在硬盘上。应用程序对文件访问时，先向内核提供文件的路径（如<code>/home/code/hello.c</code>)，然后由内核从根目录开始，一级一级解析路径、搜索目录，直到最终定位到文件，得到文件的相关信息，比如其存储与硬盘的何处。</p>
<p>遍历文件树的这个开销是不可忽略的，如果每一次读写文件都要从头找到它，也未免太过麻烦了。因此，linux等操作系统内核维护一个<strong>打开文件表</strong>(open-file-table)，这个列表里存放了所有目前打开的文件的信息，统一管理。</p>
<p>考虑到文件的访问者是进程，而多个进程可能同时对同一个文件进行不同位置的读写，打开文件表最终采用了<strong>两级内部表</strong>的设计。文件打开表分为了每个进程独有的一个<strong>进程表</strong>（用户打开文件表），和整个系统共用的一个<strong>系统表</strong>（系统打开文件表）。进程表的每个条目相应地指向系统表的条目，而系统表的条目再指向文件的具体位置。两级内部表使得多个进程打开同一个文件时，重叠部分不必反复存储，因而开销增长变得很小。</p>
<p>从进程的角度看，在显式地打开文件后，对文件进行读写操作时，直接通过自己进程表的索引(index)来指定文件。而进程表的索引，这个非负的整数，就是**文件描述符(file descriptor, fd)**。</p>
<p><img src="/2021/08/07/c_cpp_about_file_io/1628327993815.png" srcset="/img/loading.gif" lazyload></p>
<p>读写一个文件所需要的信息被分级存储在了系统表和进程表条目上。系统表条目中，存储了与进程无关的信息，例如文件在磁盘上的位置、访问日期和文件大小等，并维护一个**打开计数(open count)**。而进程表条目中，存储了进程对文件的使用信息，如文件指针、访问权限等。</p>
<p>更具体而言，进程对文件的访问流程如下：</p>
<p><img src="/2021/08/07/c_cpp_about_file_io/1628328023076.png" srcset="/img/loading.gif" lazyload></p>
<p>进程表条目、系统表条目、目录项和inode的概念概括如下：</p>
<ol>
<li><p><strong>进程表条目（文件描述符）</strong></p>
<p> 文件描述符是一个进程级的概念，因此，脱离进程去考虑它是无意义的。它的存在地位类似于一个文件指针<code>FILE *</code>，不同的文件描述符也可能指向同一个文件。</p>
</li>
<li><p><strong>系统表条目</strong></p>
<p> 系统表条目指示一个被打开的文件。它的数据结构里面存储了打开计数，也就是有多少个进程正打开了该文件。因此，系统表条目的存在说明该文件被至少一个进程打开，可能有读可能有写。它的里面直接存储inode的链接，而不存储目录下的链接，但inode的查找需要通过遍历目录项来得到。因此，对于已打开文件，其路径信息可以认为是被抹去的。</p>
</li>
<li><p><strong>目录项(dentry)</strong></p>
<p> 目录项是文件树的组成节点，所有路径查找都是通过目录项的逐级跳转实现的。其存有父子节点链接，文件名和inode链接等。解析路径查找文件的过程便是在目录项上逐级跳转，但在找到了文件之后，我们便不再关心它了。也就是说，文件的编辑和移动其实是分离的，你不能把移动文件视作某一种对文件内容的编辑。</p>
</li>
<li><p><strong>inode</strong></p>
<p> inode存储了字节数、UserID、GroupID、读写执行权限、时间戳等文件的元信息，和指向存有文件数据的block的链接。inode号码与文件名相分离，也就是说，inode不知情文件的路径、文件名等信息，不关心文件在文件树中的位置。不考虑硬链接的情况下，可以认为inode号就是文件的唯一标识。再四舍五入一下，可以近似认为inode就是文件本身（毕竟所有对文件的操作都绕不开inode）。</p>
</li>
</ol>
<h2 id="文件描述符-file-descriptor"><a href="#文件描述符-file-descriptor" class="headerlink" title="文件描述符(file descriptor)"></a>文件描述符(file descriptor)</h2><p>以上是操作系统层面对文件描述符的理解。但在实际应用中，我们更关心如何在软件开发层面理解它。</p>
<p>正如上文所说，在unix中，文件在进程中通常抽象化表示为一个文件描述符。</p>
<p>文件描述符是一个非零整数，用以标明每一个被进程所打开的文件。每次打开文件时，按照升序为其分配未被占用的非零整数。例如，第一个打开的文件分配为0，第二个分配为1，若为0的文件被关闭，则下一个打开的文件分配获得的文件描述符则为0。</p>
<ul>
<li>同一个进程内，不同的文件描述符也可能指向同一个文件</li>
<li>不同进程间，同一个文件描述符可能指向不同文件</li>
</ul>
<p>因为文件描述符是一个进程自己的进程表的序号，所以对于不同的进程，比较它们的文件描述符没有什么意义。但事实上，它们也可以跨进程地发挥用处，因为在进程<code>fork()</code>之后，子进程会复制父进程的进程表，父进程的文件描述符都会被继承，且指向相同的文件（系统表的相同位置）。这也称作父子进程间的文件共享。</p>
<p>而在同一个进程内，如果你多次打开同一个文件，那么你将得到多个不同的文件描述符，而它们指向同一个文件（系统表的相同位置）。不同的文件描述符之间不会彼此影响，哪怕它们事实上指向同一文件，你也需要将它们一一关闭，而不是关闭其中一个即可，即“内核的归内核管，程序员的归程序员管”。</p>
<p>总之，你其实不关心它们是否指向同一个文件。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/test1280/article/details/80293294">C/C++：文件描述符与进程之间的关系</a></p>
<h2 id="标准I-O与系统I-O"><a href="#标准I-O与系统I-O" class="headerlink" title="标准I/O与系统I/O"></a>标准I/O与系统I/O</h2><p>对文件描述符的操作是管理文件的基本方式，但却不是我们熟悉的方式。任何一个学过C的人都不会对下面的代码感到陌生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br>    FILE *file = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;%s&quot;</span>, str);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>而对这种下面的这段代码，恐怕没有那么熟悉。（也有可能，你是一个酷爱管理所有底层细节的C语言专家）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>    write(fd, str, <span class="hljs-keyword">sizeof</span>(str));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（当我第一次看到<code>int fd</code>时，我确实被搞糊涂了，现在你可以知道它是一个文件描述符）</p>
<p>基于文件指针<code>FILE *</code>的I/O（或者标准I/O），实际上是C语言对基于文件描述符的I/O（或者系统I/O）的一层封装，用<code>fprintf()</code>、<code>fscanf()</code>等替代<code>read()</code>和<code>write()</code>。每个<code>FILE</code>对象中存储了一个文件描述符。二者之间可以进行自由的相互转换。大多数时候它们是一一对应的关系，只要你不捣乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 用两种不同的方式打开文件</span><br>    FILE *file1 = fopen(<span class="hljs-string">&quot;example-1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-type">int</span> fd2 = open(<span class="hljs-string">&quot;example-2.txt&quot;</span>, O_WRONLY | O_CREAT);<br>    <br>    <span class="hljs-comment">// 相互转换</span><br>    <span class="hljs-type">int</span> fd1 = fileon(file1);<br>    FILE *file2 = fdopen(fd2, <span class="hljs-string">&quot;w+&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>标准I/O和系统I/O都是对I/O的操作不同风格的管理，简要对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>标准I/O</th>
<th>系统I/O</th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td><code>stdio.h</code></td>
<td><code>io.h</code></td>
</tr>
<tr>
<td>文件表示</td>
<td><code>FILE *</code> (文件指针)</td>
<td><code>int</code> (文件描述符)</td>
</tr>
<tr>
<td>打开文件</td>
<td><code>fopen()</code></td>
<td><code>open()</code></td>
</tr>
<tr>
<td>关闭文件</td>
<td><code>fclose()</code></td>
<td><code>close()</code></td>
</tr>
<tr>
<td>常用写出</td>
<td><code>fprintf()</code></td>
<td><code>write()</code></td>
</tr>
<tr>
<td>常用读入</td>
<td><code>fscanf()</code></td>
<td><code>read()</code></td>
</tr>
<tr>
<td>标准输入</td>
<td><code>stdin</code></td>
<td><code>STDIN_FILENO</code> (即<code>0</code>)</td>
</tr>
<tr>
<td>标准输出</td>
<td><code>stdout</code></td>
<td><code>STDOUT_FILENO</code> (即<code>1</code>)</td>
</tr>
<tr>
<td>标准错误</td>
<td><code>stderr</code></td>
<td><code>STDOUT_FILENO</code> (即<code>2</code>)</td>
</tr>
<tr>
<td>特点</td>
<td>流处理，有缓冲区</td>
<td>更低级些</td>
</tr>
</tbody></table>
<p>标准I/O除了封装了各个数据类型与字符串之间的转换(也就是<code>%d</code>，<code>%f</code>那些），还使用了<strong>缓冲技术</strong>，当数据写入时并没有立即把数据交给内核，而是先存放在缓冲区(buffer)中，当缓冲区满时，会一次性把缓冲中的数据交给内核写到文件中，这样就减少内核态与用户态的切换次数。而系统I/O每写一次数据就要进入一次内核态，这样就浪费了大量时间进行内核态与用户态的切换，因此用时更长。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joeblackzqq/archive/2011/04/11/2013010.html">open和fdopen的区别 清清飞扬</a></p>
<p>系统I/O则是操作系统双手的延申，可以实现字节级别的数据管理，即时性高，它比较适合底层开发。而缓冲区策略则更适合日常的应用场景。</p>
<h2 id="缓冲区的潜在问题"><a href="#缓冲区的潜在问题" class="headerlink" title="缓冲区的潜在问题"></a>缓冲区的潜在问题</h2><p>缓冲区的设计在大部分日常场景下都是高效的，但它存在一些潜在的问题。</p>
<p>缓冲区机制虽然试图表现得透明，然而它<strong>并不是透明的</strong>。就像缓存(cache)会因更新不及时导致读到的数据不符预期，缓冲不及时也会导致错误的（甚至是匪夷所思的）写出结果。</p>
<p>以下是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *file = fopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;hello\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>1.out</code>中的输出如下：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">hello</span><br><br></code></pre></td></tr></table></figure>

<p>可以看到，我们的程序只进行了一次写，却产生了两份输出。究其原因，是因为程序在执行完第8行后，并没有真正把结果写入<code>1.out</code>中，而是将其放入了缓冲区，等进程结束时才统一写入。然而，<code>fork()</code>产生的子进程拷贝了父进程的缓冲区和文件描述符，因此，子进程和父进程结束时，分别进行了一次缓存更新，总共产生了两次写入。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/amei113/article/details/84642479">标准输出缓存在多进程代码中引起的一个问题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sir-jarvis/p/4075850.html">C标准I/O缓冲区：全缓冲和行缓冲</a></p>
<p>针对不同的场景，标准I/O预设了三种缓冲区，分别是全缓冲、行缓冲和无缓冲。</p>
<ul>
<li>全缓冲：仅当I/O缓冲区被填满，或者文件被关闭，或进程结束时，才刷新缓冲区，进行实际I/O操作。也可以执行<code>fflush()</code>手动刷新。读写一般文件默认为全缓冲。</li>
<li>行缓冲：标准输入、标准输出流都是采用行缓冲。也就是每次换行时进行实际I/O操作。</li>
<li>无缓存：标准错误流就是采用无缓冲。第一时间进行I/O。（正如系统I/O）</li>
</ul>
<p>它们具有不同的更新及时性。更新的越及时，I/O负担越大，有时是不必要的；而更新的越不及时，越有可能通过合并I/O提升效率，但有可能产生预期外的表现。当然，你也可以手动更改指定文件的缓冲区类型。</p>
<p>正是因为标准I/O对一般文件的读写默认为全缓冲，因此会出现这种情况：程序写入日志时，外部打开文件总是看不见更新，得等程序关闭该文件时，或者程序执行完毕时，才能拿到输出。</p>
<p>正如你所见，你应当对缓冲区问题保持一定的警惕。这可不是什么闭着眼睛用就能发挥奇效的东西，当问题发生时，你和计算机之间，总会有一个在自作聪明。</p>
<p>基于类似的理由，当你在混合使用<code>printf()</code>和<code>write()</code>时，二者的输出顺序与代码的执行顺序是否一致，会取决于你将其重定向至一个文件或是终端。这很有可能导致“bug仅出现于生产环境下”的欺骗性灾难。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;byebye\n&quot;</span>, <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./test<br>hello<br>byebye<br>$ ./test &gt; 1.out | <span class="hljs-built_in">cat</span> 1.out<br>byebye<br>hello<br></code></pre></td></tr></table></figure>

<p>我会向你展示更多例子，证明标准I/O和系统I/O的混合使用不会是一个好的主意。</p>
<h2 id="混合使用标准I-O与系统I-O的潜在问题"><a href="#混合使用标准I-O与系统I-O的潜在问题" class="headerlink" title="混合使用标准I/O与系统I/O的潜在问题"></a>混合使用标准I/O与系统I/O的潜在问题</h2><p>尽管文件描述符和文件指针之间可以进行自由的相互转换，也可以创建多个文件指针指向同一个文件描述符，将二者混合使用，不过很少这么做。</p>
<p>一方面是因为文件描述符在通过<code>open()</code>创建时已经制定了读写类型（只读、只写、可读写等），而在使用<code>fdopen()</code>转换时需要指定该文件指针的流形态(<code>mode</code>)，此形态必须和原先文件描述符的读写模式相同，否则将会转换失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 以只写模式打开</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>    <span class="hljs-comment">// 又转换为只读模式(无效, 返回NULL)</span><br>    FILE *file = fdopen(fd, <span class="hljs-string">&quot;r&quot;</span>);<br><br>    <span class="hljs-type">char</span> line[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot;%s&quot;</span>, line); <span class="hljs-comment">// error</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（还好，你至少能知道它失败了）</p>
<p>另一方面是因为，当多个文件指针指向同一个文件描述符时，调用了<code>fclose()</code>后，相应的文件描述符<code>fd</code>也会被关闭，导致其他文件指针无效。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112549454">谨慎使用fdopen函数 赵俊民</a></p>
<p>如果需要多个文件指针指向同一个文件，且分别管理生命周期，正确的使用方式应该是：用<code>dup()</code>复制文件描述符，确保文件描述符和文件指针是<strong>一一对应</strong>的关系。</p>
<p>总之，应避免二者的混合使用。</p>
<blockquote>
<p>Note that mixing use of FILEs and raw file descriptors canproduce unexpected results and <strong>should generally be avoided</strong>.  (Forthe masochistic among you: POSIX.1, section 8.2.3, describes indetail how this interaction is supposed to work.)  A general ruleis that file descriptors are handled in the kernel, while stdiois just a library.  This means for example, that after anexec(3), the child inherits all open file descriptors, but allold streams have become inaccessible.</p>
<p><a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man3/stdin.3.html">stdin(3) — Linux manual page</a><br>来自Manual的警告</p>
</blockquote>
<h2 id="标准输入-stdin-，标准输出-stdout-，标准错误-stderr"><a href="#标准输入-stdin-，标准输出-stdout-，标准错误-stderr" class="headerlink" title="标准输入(stdin)，标准输出(stdout)，标准错误(stderr)"></a>标准输入(stdin)，标准输出(stdout)，标准错误(stderr)</h2><p>除了对硬盘里文件的读写，还有一种最常见的读写，便是与程序员通过终端(terminal)画面和键盘进行的交互。程序读取终端里键入的一行内容，作为输入，然后将各种信息打印到终端画面上，作为输出。这便是我们熟悉的标准输入、输出。</p>
<p><img src="/2021/08/07/c_cpp_about_file_io/1628407729122.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>在正常情况下，每个 UNIX 程序在启动时都会为其打开三个流，一个用于输入，一个用于输出，一个用于打印诊断或错误消息。这些通常附加到用户的终端），但可能会引用文件或其他设备，具体取决于父进程选择设置的内容。<br><a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man3/stdin.3.html">stdin(3) — Linux manual page</a></p>
</blockquote>
<p>也就是说，对于每个程序（进程），在开始运行时都获得了默认的的标准输入（0），标准输出（1），标准错误（2）的文件描述符。操作系统贴心地将标准输入、标准输出、标准错误被<strong>抽象成了文件</strong>，将标准输入、输出文件与终端界面、键盘相连接，使得程序员可以将对它们的读写等价地理解为对文件的读写。</p>
<table>
<thead>
<tr>
<th></th>
<th>标准I/O</th>
<th>系统I/O</th>
</tr>
</thead>
<tbody><tr>
<td>文件表示</td>
<td><code>FILE *</code> (文件指针)</td>
<td><code>int</code> (文件描述符)</td>
</tr>
<tr>
<td>标准输入</td>
<td><code>stdin</code></td>
<td><code>STDIN_FILENO</code> (即<code>0</code>)</td>
</tr>
<tr>
<td>标准输出</td>
<td><code>stdout</code></td>
<td><code>STDOUT_FILENO</code> (即<code>1</code>)</td>
</tr>
<tr>
<td>标准错误</td>
<td><code>stderr</code></td>
<td><code>STDOUT_FILENO</code> (即<code>2</code>)</td>
</tr>
</tbody></table>
<p>如果你觉得0，1，2在程序中看起来像一个幻数，可以使用<code>STDIN_FILENO</code>等宏定义来替代它们。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 等价</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;hello world!\n&quot;</span>);<br><span class="hljs-comment">// 等价</span><br>write(STDOUT_FILENO, <span class="hljs-string">&quot;hello world!\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>) - <span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello world!\n&quot;</span>, <span class="hljs-number">13</span>);<br></code></pre></td></tr></table></figure>

<p>子进程的标准输入、输出、错误的文件标识符和文件指针与一般文件一样，都继承自父进程。因此，对于被重定向的父进程，其产生的子进程也会被重定向至相同文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    freopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father: hello world!\n&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>); \\ 文件缓冲问题<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son: hello world!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上，我很好奇操作系统是如何将标准输入、输出文件与终端界面、键盘进行连接的。这似乎与tty有关，我对此不太了解。大致来说是，在Linux系统中，控制台终端有一些设备特殊文件与之相关联，名如tty0、tty1、tty2等，可以通过shell命令<code>tty</code>命令显示终端机连接标准输入设备的文件具体名称，例如<code>/dev/tty1</code>等。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009082089">Linux TTY/PTS概述</a></p>
<p><img src="/2021/08/07/c_cpp_about_file_io/1628328043767.gif" srcset="/img/loading.gif" lazyload></p>
<p>c语言中，<code>int isatty(int fd)</code>可以检测文件描述符<code>fd</code>所指向的文件是否为一终端机，<code>char *ttyname(int fd)</code>则返回<code>fd</code>对应的终端机文件名称。<br>可以用这种方式检验标准流是否被重定向。例如，如果<code>isatty(STDOUT_FILENO) == 0</code>，那么当前标准输出流被重定向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %d, %s\n&quot;</span>, i, isatty(i), ttyname(i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>“标准”输入/输出的名称有许多种理解，在我看来，这个“标准”更多是“默认”的意思，它是每个进程默认具备的输入、输出方式，且默认指向了终端机上。如果是这样，我们也可以通过修改它来使得它看起来不再那么“标准”。</p>
<p>对终端的读写被抽象为了文件（tty文件），而0，1，2等标准输入输出的文件描述符又指向这些文件，因而构成了对终端的读写。然而，我们可以更改文件描述符的指向，让标准输入/输出不指向终端，而是某个文件，或者让其他文件描述符指向终端的输入、输出。</p>
<p>对标准输入/输出的重定向无异于对文件的重定向。</p>
<p>如果我们希望更改输入、输出的目标，对于我们可以控制的代码部分，将<code>printf()</code>全部替换成<code>fprintf()</code>就可以更改输入、输出流的指向文件（这太容易了）。然而，当我们需要执行其他程序，而这些程序又严格地使用标准输入输出时，就只能通过重定向的方式更改输入、输出的目标。具体而言，就是更改文件描述符<code>0</code>，<code>1</code>，<code>2</code>，或者是<code>stdin</code>，<code>stdout</code>，<code>stderr</code>所指向的文件。</p>
<p>就不罗嗦了，直接上代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -a &gt; 1.out<br></code></pre></td></tr></table></figure>

<h3 id="标准I-O风格"><a href="#标准I-O风格" class="headerlink" title="标准I/O风格"></a>标准I/O风格</h3><p>关闭<code>stdout</code>原先指向的文件(tty)，然后令<code>stdout</code>指向我们指定的文件。也可以用<code>freopen(&quot;1.out&quot;, &quot;w&quot;, stdout);</code>代替，这个操作OI选手应该不会陌生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> cmd[] = <span class="hljs-string">&quot;/usr/bin/ls&quot;</span>;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        fclose(<span class="hljs-built_in">stdout</span>);<br>        <span class="hljs-built_in">stdout</span> = fopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>        <br>        execv(cmd, argv);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="系统I-O风格"><a href="#系统I-O风格" class="headerlink" title="系统I/O风格"></a>系统I/O风格</h3><p>将文件描述符0，1，2所指向的文件进行替换，即可实现标准流重定向。<code>dup2(int oldfd, int newfd)</code>将关闭<code>newfd</code>原先指向的文件，并将其指向<code>oldfd</code>所指向的文件，实现定向的文件标识符复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> cmd[] = <span class="hljs-string">&quot;/usr/bin/ls&quot;</span>;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>        dup2(fd, STDOUT_FILENO);<br>        <br>        execv(cmd, argv);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>希望对你有帮助！</p>
<p>下次写关于匿名管道。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C-C/">#C/C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C/C++：关于文件I/O</div>
      <div>http://example.com/2021/08/07/c_cpp_about_file_io/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年8月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/08/cpp_tutor_0/" title="C++助教问题汇总0">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++助教问题汇总0</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"MejAYv6jIgbPXomU6XXhbUdA-gzGzoHsz","appKey":"6GUPrenF6Q0v4BzFqi4GCJ56","path":"window.location.pathname","placeholder":"评论支持markdown语法","avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
