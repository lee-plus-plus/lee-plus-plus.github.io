<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++助教问题汇总2</title>
    <link href="/2022/10/08/cpp_tutor_2/"/>
    <url>/2022/10/08/cpp_tutor_2/</url>
    
    <content type="html"><![CDATA[<p>周四实验课遇到的高频编程问题，简单汇总了一下。</p><span id="more"></span><h2 id="随机数生成为什么要初始化种子"><a href="#随机数生成为什么要初始化种子" class="headerlink" title="随机数生成为什么要初始化种子"></a>随机数生成为什么要初始化种子</h2><p>同学们看起来有两个疑惑：</p><ol><li>为什么我要初始化种子？</li><li>为什么我又不能每次都初始化种子？</li></ol><p>这要从（伪）随机数的原理，<strong>线性同余算法</strong>讲起。我先用一个简单的例子引入：</p><h3 id="线性同余算法"><a href="#线性同余算法" class="headerlink" title="线性同余算法"></a>线性同余算法</h3><p><img src="/2022/10/08/cpp_tutor_2/cpp_tutor_20.png" alt="用计算机展开1÷67的小数部分"></p><p>1÷67的小数部分，看起来特别没有规律。<br>如果我每次截取小数点后面的3个数字，我们将得到：014，925，373，134，328，……。<br>看，如果我不告诉你这些数字的产生原理，是不是看起来我就像拥有了一个0~999的随机数发生器？</p><p>线性同余算法 (Linear congruential generator) 正是基于类似的原理。<br>照搬百度百科上的定义，设 $X_n$ 是产生的第 $n$ 的（伪）随机数，$a, b, c$ 为固定整数参数，则线性同余发生器（LCG）的定义如下，</p><p>$$<br>X_{n+1} = (a X_{n} + c) \  \rm{mod} \  m<br>$$</p><p>通过选取不同的参数 $a, b, c$, 这个伪随机序列 ${ X_n }$ 可以任意变换。如果你只能观测这个序列已产生的部分，不知道它的参数，也是<strong>不可能预测</strong>这个序列之后的部分的。</p><p><img src="/2022/10/08/cpp_tutor_2/cpp_tutor_21.png" alt="1÷67是有理数，小数部分必定有循环节"></p><p>当然，线性同余算法也有缺陷，就是这个序列一定有周期，不过只要周期足够大，就可以不考虑这个问题。</p><h3 id="随机种子-Random-Seed"><a href="#随机种子-Random-Seed" class="headerlink" title="随机种子 (Random Seed)"></a>随机种子 (Random Seed)</h3><p>为了确保线性同余序列的周期足够大，或者说这个参数的质量足够优良，通常 $a$, $b$ 和 $m$ 是数学家找好以后写死在代码里的。下面是一个线性同余生成器的实现，其中$a=214013$, $b=2531011$, $m=32768$（截取的不是尾部1-15位，而是31到16位，略有差异无妨）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _next = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">my_rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    _next = _next * <span class="hljs-number">214013L</span> + <span class="hljs-number">2531011L</span>;<br>    <span class="hljs-keyword">return</span> ((_next &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0x7fff</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">my_rand</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果是</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">38</span><br><span class="hljs-number">7719</span><br><span class="hljs-number">21238</span><br><span class="hljs-number">2437</span><br><span class="hljs-number">8855</span><br></code></pre></td></tr></table></figure><p>但是，这个程序每次运行时给出的结果都是一样的。毕竟，运算方式都是固定在里面的，而初值也一直都是0。</p><p>因此，我们引入随机数种子的概念。它其实就是用不同的值对<code>_next</code>进行初始化，相当于在这个周期超长的伪随机序列上<strong>选取不同的起点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _next = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_srand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> seed)</span> </span>&#123;<br>    _next = seed;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">my_rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    _next = _next * <span class="hljs-number">214013L</span> + <span class="hljs-number">2531011L</span>;<br>    <span class="hljs-keyword">return</span> ((_next &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0x7fff</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> seed = <span class="hljs-number">1</span>; seed &lt;= <span class="hljs-number">5</span>; seed++) &#123;<br>        <span class="hljs-built_in">my_srand</span>(seed);<br>        cout &lt;&lt; <span class="hljs-string">&quot;set seed &quot;</span> &lt;&lt; seed &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">my_rand</span>() &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> seed <span class="hljs-number">1</span>: <span class="hljs-number">41</span> -&gt; <span class="hljs-number">18467</span> -&gt; <span class="hljs-number">6334</span> -&gt; <span class="hljs-number">26500</span> -&gt; <span class="hljs-number">19169</span> -&gt; ...<br><span class="hljs-attribute">set</span> seed <span class="hljs-number">2</span>: <span class="hljs-number">45</span> -&gt; <span class="hljs-number">29216</span> -&gt; <span class="hljs-number">24198</span> -&gt; <span class="hljs-number">17795</span> -&gt; <span class="hljs-number">29484</span> -&gt; ...<br><span class="hljs-attribute">set</span> seed <span class="hljs-number">3</span>: <span class="hljs-number">48</span> -&gt; <span class="hljs-number">7196</span> -&gt; <span class="hljs-number">9294</span> -&gt; <span class="hljs-number">9091</span> -&gt; <span class="hljs-number">7031</span> -&gt; ...<br><span class="hljs-attribute">set</span> seed <span class="hljs-number">4</span>: <span class="hljs-number">51</span> -&gt; <span class="hljs-number">17945</span> -&gt; <span class="hljs-number">27159</span> -&gt; <span class="hljs-number">386</span> -&gt; <span class="hljs-number">17345</span> -&gt; ...<br><span class="hljs-attribute">set</span> seed <span class="hljs-number">5</span>: <span class="hljs-number">54</span> -&gt; <span class="hljs-number">28693</span> -&gt; <span class="hljs-number">12255</span> -&gt; <span class="hljs-number">24449</span> -&gt; <span class="hljs-number">27660</span> -&gt; ...<br></code></pre></td></tr></table></figure><p>现在告诉你，这份代码是对Windows上的C++随机数内部实现的严格复现（源代码写得更绕一些）。将<code>my_srand()</code>和<code>my_rand()</code>换为<code>srand()</code>和<code>rand()</code>，结果将是<strong>完全一致</strong>的（请动手试一试）！</p><p>是不是，原理也没那么复杂？</p><h3 id="何时重置种子"><a href="#何时重置种子" class="headerlink" title="何时重置种子"></a>何时重置种子</h3><p>回到那个问题</p><blockquote><ol><li>为什么我要初始化种子？</li><li>为什么我又不能每次都初始化种子？</li></ol></blockquote><p>线性同余生成器确保了每次调用<code>rand()</code>时总在一个伪随机序列环上取数，上一个数和下一个数看之间看不出关联性，但每次程序运行时都从该环的同一个位置开始行走，每次都将输出相同的随机数序列。因此，用时间作为种子，可以使得不同时间运行的同一份程序从该环的不同位置上开始行走。然而，如果在每次取随机数时都用时间赋种子，则随机数生成器退化成报时器。</p><hr><p>感谢W的屁股蛋子！<br>封面来自小日子老师@Liduke的微博。</p>]]></content>
    
    
    <categories>
      
      <category>C++助教问题汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++助教问题汇总1</title>
    <link href="/2022/10/01/cpp_tutor_1/"/>
    <url>/2022/10/01/cpp_tutor_1/</url>
    
    <content type="html"><![CDATA[<p>周四实验课遇到的高频编程问题，简单汇总了一下。</p><span id="more"></span><h2 id="如何进行断点调试"><a href="#如何进行断点调试" class="headerlink" title="如何进行断点调试"></a>如何进行断点调试</h2><blockquote><p>程序不动了是迭代次数太多了吗?</p></blockquote><p>遇到这种情况先考虑是不是死循环了。<br>检查你的循环跳出条件，打断点，监视那些关键变量的变化是否符合预期。</p><p><img src="/2022/10/01/cpp_tutor_1/answer13.png" alt="断点调试是你强大的工具"></p><p>程序出现运行时Bug（和令代码无法通过编译的Bug相区分）时，常用的<strong>调试手段</strong>有两种。</p><p>第一种是 <strong>打日志(log)</strong> 。</p><p><img src="/2022/10/01/cpp_tutor_1/5.gif" alt="直接把关键变量的值打印出来"></p><p>第二种是 <strong>断点(breakpoint)调试</strong> 。</p><p>首先在想要停下的行打上断点，这样调试运行时到此处会自动停下。</p><p><img src="/2022/10/01/cpp_tutor_1/1.gif" alt="在该行打上断点"></p><p>编译选项要选Debug，如果处在Release状态下运行，断点调试将被忽略。</p><p>点击“本地Windows调试器”开始调试。运行后程序将停在第一个断点处，黄色箭头（红色断点的上面）指示当前程序所执行到的位置。黄色箭头位于第7行，表示前面的都执行过一遍了，而当前所在行（第7行）还未执行。</p><p><img src="/2022/10/01/cpp_tutor_1/2.gif" alt="开始调试"></p><p>调试中断时，鼠标放在变量上面能显示它当前值，或者看下方的“局部变量”表也行。因为第7行还未执行，此时变量<code>i</code>的值为0。</p><p>点工具栏上面的“逐语句(F11)”，可以让程序往前执行一行。边上的“逐过程(F10)”其实也行，它们的区别在于遇到对函数的调用时，是跳进去继续追踪，还是等它跳出来再追踪。<br>连续点击“逐语句(F11)”，令程序连续执行好几步，这个过程中你可以观察变量i的值的变化情况。</p><p><img src="/2022/10/01/cpp_tutor_1/3.gif" alt="单步执行"></p><p>逐语句运行时，每走一行，就停下来给你观察现场，并等待你决定接下来做什么。</p><p>把断点去掉以后点“继续”，程序就会继续不停地运行，也就是死循环，因为没有输出所以看起来就是黑窗口上只有光标在闪。</p><p>不想调试了就点那个方形的“停止调试”，程序就将结束。</p><p><img src="/2022/10/01/cpp_tutor_1/4.gif" alt="结束调试"></p><h2 id="inf，NaN是什么意思"><a href="#inf，NaN是什么意思" class="headerlink" title="inf，NaN是什么意思"></a>inf，NaN是什么意思</h2><p>inf，NaN是浮点数(float，double)数据类型中非常特殊的两个取值。</p><p>inf是无穷大(infinity)的缩写，对一个正数除0.0就会得到inf，对负数除0.0会得到负的inf，或者当试图用double存储一个超过其表示范围的数，比如说<code>1e99999</code>，也会导致它变成inf) </p><p>NaN是非数字(Not A Number)的缩写，对负数开平方，对负数取对数，0.0除以0.0，0.0乘inf， inf除以inf等错误都会得到NaN</p><p>当你的浮点运算产生上述不合法运算时，程序不会直接报错，而是使你的运算结果变为这种特殊值。这种特殊值会在运算过程中不断传递，污染后续运算 (NaN加减乘除任何数还是NaN)。</p><p>当打印这两种特殊的数值时，控制台(console)会显示<code>inf</code>，<code>-nan(ind)</code>，如果你使用的是Visual Studio。或者你使用的是Dev C++等基于g++编译器的IDE，则显示为<code>inf</code>，<code>nan</code>。这只是显示方式上的区别! </p><p>示例代码如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> zero = <span class="hljs-number">0.0</span>;<br><br>    cout &lt;&lt; (x / zero) &lt;&lt; endl;    <span class="hljs-comment">// inf</span><br>    cout &lt;&lt; (-x / zero) &lt;&lt; endl;   <span class="hljs-comment">// -inf</span><br><br>    cout &lt;&lt; (<span class="hljs-built_in">sqrt</span>(-x)) &lt;&lt; endl;    <span class="hljs-comment">// nan</span><br>    cout &lt;&lt; (<span class="hljs-built_in">log</span>(-x)) &lt;&lt; endl;     <span class="hljs-comment">// nan</span><br>    cout &lt;&lt; (zero / zero) &lt;&lt; endl; <span class="hljs-comment">// nan</span><br><br>    <span class="hljs-type">double</span> inf = x / zero;         <span class="hljs-comment">// nan</span><br><br>    cout &lt;&lt; (zero / zero) &lt;&lt; endl; <span class="hljs-comment">// nan</span><br>    cout &lt;&lt; (zero * inf) &lt;&lt; endl;  <span class="hljs-comment">// nan</span><br>    cout &lt;&lt; (inf / inf) &lt;&lt; endl;   <span class="hljs-comment">// nan</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/01/cpp_tutor_1/answer14.png" alt="Visual Studio运行结果"></p><h2 id="x-y不是x的y次方吗"><a href="#x-y不是x的y次方吗" class="headerlink" title="x^y不是x的y次方吗"></a>x^y不是x的y次方吗</h2><p>在C++里不是。</p><p>C++ 的<code>^</code>运算符不是次幂运算符，这是数学符号习惯带来的第一个常见误会，下面的这个示例代码可以最直接地证明这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><br>    cout &lt;&lt; (x ^ y) &lt;&lt; endl; <span class="hljs-comment">// 3, not 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管代码可以通过编译并正常运行，但<code>^</code>在C++中是“异或运算符”，属于位运算符的一种(详细可参考<a href="https://www.runoob.com/cplusplus/cpp-operators.html">这篇博客</a>)。C++不存在次幂运算符，不过你可以调用cmath库中的<code>pow()</code>指数函数来做到这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><br>    cout &lt;&lt; <span class="hljs-built_in">pow</span>(x, y) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单独cpp文件不能编译运行吗"><a href="#单独cpp文件不能编译运行吗" class="headerlink" title="单独cpp文件不能编译运行吗"></a>单独cpp文件不能编译运行吗</h2><blockquote><p>为什么Visual Studio打开单独cpp文件不能运行，但交作业只需单独cpp文件？</p></blockquote><p>这个问题解释起来有些复杂……<br>一言以蔽之，Visual Studio试图让“多文件联合编译”这个问题变得简单，但反而令“单文件编译”变得繁琐。</p><h3 id="多文件联合编译是C-的常态"><a href="#多文件联合编译是C-的常态" class="headerlink" title="多文件联合编译是C++的常态"></a>多文件联合编译是C++的常态</h3><p>尽管刚开始这门课的时候，大家编写的C++程序只放在一个文件里，但在工程上，一个完整的C++程序项目，代码分散地放在数百个文件里是非常正常的事情。</p><p>这是我大三时编译原理实践的放C++代码的目录结构。编译时，需要将所有这些文件里的代码合并到一起编译，才能产生一个程序。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sly<br>├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CMakeLists</span>.</span></span>txt<br>├── <span class="hljs-keyword">include</span><br>│     └── sly<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Action</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotatedParseTree</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AttrDict</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ContextFreeGrammar</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FaModel</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FileAnalyzer</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LrParser</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Production</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RegEx</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SeuLex</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SeuYacc</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream2TokenPipe</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableGenerateMethod</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableGenerateMethodImpl</span>.</span></span>h<br>│         ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Token</span>.</span></span>h<br>│         ├── def.h<br>│         ├── sly.h<br>│         └── utils.h<br>└── src<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Action</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotatedParseTree</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AttrDict</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ContextFreeGrammar</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FaModel</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LrParser</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Production</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RegEx</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SeuLex</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SeuYacc</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream2TokenPipe</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableGenerateMethod</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableGenerateMethodImpl</span>.</span></span>cpp<br>    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Token</span>.</span></span>cpp<br>    ├── sly.cpp<br>    └── utils.cpp<br></code></pre></td></tr></table></figure><p>你肯定会想到，为了让编译器知道哪些文件需要参与编译，当然要有个地方存储这样一个索引。对于Visual Studio来说，你所新建的这个“项目”(Project)就主要做了这件事。<br>正是因为“项目”索引了该工程所涉及的所有代码文件，才使得Visual Studio得以提供跨文件的代码智能提示功能(intellisense)，一键的“编译并运行”功能，智能跳转功能以及许许多多便捷功能，使得它荣获“宇宙第一IDE”之美称。</p><p>在业界，大部分时候一个单独的cpp文件都是不完整的(你的程序必须包含一个且最多一个<code>main()</code>才能编译运行)，所以Visual Studio被设计成了，在任何时候都需要<strong>先有一个项目</strong>(其中指明了存在哪些代码文件)才能编译运行。哪怕你的确只有一个cpp文件，你也需要先建立一个项目，再一步步正确地把代码文件添加进去。</p><p>对于使用Dev C++的同学，自然不会被这个问题困扰，因为和Visual Studio<strong>默认多文件联合编译</strong>相反，Dev C++<strong>默认进行单文件编译</strong>。你打开的是哪个文件，就编译运行的是哪个文件。如果只是经常写一些单文件的C++代码，那么无需每次都繁琐地建立工程文件，无疑是Dev C++的一大优势。</p><blockquote><p>我还是要提醒一句，Visual Studio的编译器(msvc)和Dev C++的编译器(g++)的表现是<strong>不完全一样</strong>的，尤其是对变量未赋初值的处理方式是不同的。曾经就有同学习惯了g++贴心的变量初值自动置零，而忘记手动赋初值，最后在考场上被msvc狠狠制裁，丢了好几分。</p></blockquote><h3 id="构建系统-build-system-不取决于打开了哪些文件"><a href="#构建系统-build-system-不取决于打开了哪些文件" class="headerlink" title="构建系统(build system)不取决于打开了哪些文件"></a>构建系统(build system)不取决于打开了哪些文件</h3><p>Visual Studio是一款IDE(Integrated Development Environment, 集成开发环境)，这意味着它集成了C++的构建系统(也就是你点击“编译”时所运行的系统)，能从代码文件生成可执行程序。而构建系统的基础，则在于如何找到生成最终程序所需的各个源代码文件。<br>构建系统也会随着你添加、删除<strong>项目中的代码文件</strong>而需要动态地变化。</p><p>但是什么叫做“项目中的代码文件”呢，是看它是否出现在了编辑器(也就是屏幕占比最大的中间那块编辑区域)里吗？不是的，对于Visual Studio来说，在“解决方案资源管理器”里看到的树状结构才是它认为的“项目中的代码文件”。</p><p><img src="/2022/10/01/cpp_tutor_1/cpp_tutor_11.png" alt="“解决方案资源管理器”中，引用、外部依赖项、头文件、源文件下面的文件，都参与构建"></p><p>当你点击“编译并运行”时，你在编译的不是面前的这个代码文件，而是<strong>这个项目</strong>。<br>你面前的这个代码文件，不一定在当前项目里。同时，这个项目也不一定只包括了你面前的代码文件。<br>要想知道项目到底包含了哪些文件，一切都以<strong>“解决方案资源管理器”里的树状结构</strong>为准。</p><p>总之，Visual Studio所做的并不是“把打开的代码文件一起联合编译”，而是“按照项目索引的代码文件进行联合编译”。你爱打开几个文件打开几个文件，构建系统都不会变，除非你更改“解决方案资源管理器”里的文件结构。</p><p><img src="/2022/10/01/cpp_tutor_1/answer17.png" alt="“解决方案资源管理器”中可以看到, 当前打开的AttrDict.cpp并不在该项目中，编译运行并不会带上它"></p><h3 id="单独打开cpp文件的迷惑之处"><a href="#单独打开cpp文件的迷惑之处" class="headerlink" title="单独打开cpp文件的迷惑之处"></a>单独打开cpp文件的迷惑之处</h3><p>搞清楚上面那点，其实就足够了，下面的有点偏吐槽向。</p><p>在Visual Studio的设想下，开发者可以在一个项目内，对每个代码文件进行编辑，修改后编译并运行，一切都是如此美好。</p><p>然而有些迷惑人的地方在于，Visual Studio又占据了系统中cpp文件的默认打开方式。当你双击一个cpp文件时，这个cpp文件中的代码会弹出在Visual Studio里。此时你能看到这些代码的语法高亮，能够编辑修改它们，并且这个选项卡看起来和其他的没有什么区别。</p><p><img src="/2022/10/01/cpp_tutor_1/answer15.png" alt="安装完Visual Studio后cpp文件的默认打开方式通常就变成了Visual Studio"></p><p><img src="/2022/10/01/cpp_tutor_1/cpp_tutor_10.png" alt="最前面这个AttrDict.cpp看起来很好，它并不在当前项目里，你看得出来吗(看不出来)"></p><p>按理说，我们只关心自己项目里的代码文件，既然当前打开的这个代码文件不属于我的项目，那按理说应该进入一个“临时浏览/编辑”模式，在显示方式上和项目内的代码文件做明显区分，方便我意识到它不在我项目内才对。</p><p>然而Visual Studio并没有这么做！哈哈！全都长得一模一样！</p><p>更本质的原因是，Visual Studio作为一款全能型的IDE，既包揽了编辑器的功能，又承接了维护构建系统的功能，但却只有一套IDE的界面。<br>当开发者打开项目内文件并编辑时，不仅需要语法高亮，修改了代码文件，同时也对构建系统产生影响，此时Visual Studio是作为IDE在工作。<br>但当开发者编辑项目外文件时，只是需要语法高亮，修改了代码文件，但不对构建系统产生影响，此时Visual Studio仅作为编辑器(editor)工作，这时界面上所有构建系统相关的按钮都变成了干扰视听的混淆项。</p><p>我认为规避这一问题的最好方法，就是始终从项目中打开cpp文件，而不通过cpp文件进入Visual Studio，并且将cpp文件的默认打开方式绑定到真正的编辑器上，比如notepad++，VS Code或者Sublime之类。</p><h3 id="C-构建系统的原理"><a href="#C-构建系统的原理" class="headerlink" title="C++构建系统的原理"></a>C++构建系统的原理</h3><p>当然，我的这些解释有点太过拘泥于IDE的特性，而不是在聊C++本身了。如果你的好奇心依然未被满足，想搞明白关于C++单文件/ 多文件编译的更本质一些的原理，我建议你了解一下g++，也就是从命令行编译运行C++的流程。</p><p><a href="https://www.zhihu.com/question/389406095">g++是干什么用的 学C++一定要用这个么?  - 知乎</a></p><p><a href="https://www.cs.fsu.edu/~myers/howto/g++compiling.txt">Compiling C++ programs with g++</a></p><p>兴许你会开始对makefile和Cmake感兴趣。</p><p><img src="/2022/10/01/cpp_tutor_1/answer11.png" alt="Dev C++中编译时使用的g++命令及参数"></p><p><img src="/2022/10/01/cpp_tutor_1/answer12.png" alt="Visual Studio中使用的cl命令及参数"></p><h2 id="C-逗号相关问题"><a href="#C-逗号相关问题" class="headerlink" title="C++逗号相关问题"></a>C++逗号相关问题</h2><p>我的评价是水很深。</p><h3 id="逗号不是逻辑上的“并且”"><a href="#逗号不是逻辑上的“并且”" class="headerlink" title="逗号不是逻辑上的“并且”"></a>逗号不是逻辑上的“并且”</h3><p>把逗号当作逻辑上的“并且”(and)是数学符号习惯带来的第二个常见误会，下面是一个错误的例子: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>, x &lt; <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确的做法是使用<a href="https://www.runoob.com/cplusplus/cpp-operators.html">逻辑运算符</a><code>&amp;&amp;</code>。</p><h3 id="逗号间隔的变量声明初始化是独立赋值"><a href="#逗号间隔的变量声明初始化是独立赋值" class="headerlink" title="逗号间隔的变量声明初始化是独立赋值"></a>逗号间隔的变量声明初始化是独立赋值</h3><p>逗号还有一个常见误解是用在变量声明里. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x, y, z;<br></code></pre></td></tr></table></figure><p>这固然没什么问题，但如果还要赋初值的话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x, y, z = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>请记住此时<code>x</code>和<code>y</code>并没有变成10，上述代码等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span> z = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="逗号运算符通常属于奇技淫巧"><a href="#逗号运算符通常属于奇技淫巧" class="headerlink" title="逗号运算符通常属于奇技淫巧"></a>逗号运算符通常属于奇技淫巧</h3><p>还有一种是作为<a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>使用，也称“顺序求值运算符”，用于将表达式“串联”起来，返回最后一个表达式的值。<br>常见于算法竞赛不择手段的压缩行数。</p><p>包括但不限于以下用法: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) a += <span class="hljs-number">1</span>, b += <span class="hljs-number">2</span>, c += <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; a, a != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前者是一种畸形的、邪恶的、错误的美学追求，后者有一定的实用性但需要你把握得住。 </p><p>如果你觉得你把握得住，试试看下面几个例子能不能迷倒你。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">a, b, c = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> result;<br><br>    result = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), x * x;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>感谢阅读！<br>封面来自电影《飞驰人生》截图。</p>]]></content>
    
    
    <categories>
      
      <category>C++助教问题汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++助教问题汇总0</title>
    <link href="/2022/09/08/cpp_tutor_0/"/>
    <url>/2022/09/08/cpp_tutor_0/</url>
    
    <content type="html"><![CDATA[<p>写这个专栏最初的目的<span id="more"></span>，是因为我在C++答疑的过程中，注意到有一些问题出现的频率相当之高。于是，在一次次精炼自己的表达的过程中，顺势就想着：不妨干脆把这些疑惑与解答记录下来，方便后续有需要的同学查阅。</p><p>对于C++这门重度强调编程<strong>实践</strong>的课程，每位同学的起点并不一致。有些算法竞赛出身的同学，对于C++的熟悉程度和理解已经达到了可以免修该课程的程度，而有些同学，刚刚结束了断网的高三，面对第一台属于自己的笔记本电脑，眼里还写着憧憬与陌生。而后者，在前者无害的炫耀张扬，与颇具难度的实验作业下，很容易萌生不必要的恐惧心理，为这门课的学习造成更深一步的困难。</p><p>为了帮助同学们更好地度过“C++新手期”，这个专栏将会更聚焦于一些<strong>初级</strong>的问题，尽量降低对于前置性知识的要求。<br>同时，鉴于这篇专栏的内容也以我的个人收集为主，它在组织结构上也会显得比较<strong>破碎</strong>。网络上已经存留了相当数量的优质C++教学资源，而我也并不打算再造一次轮子，因此，请将该专栏与更加成体系化的学习配套服用。我绝对是更加推荐各位同学以一个更具体系的教学框架作为主干，学习自己的第一门程序语言，并将我的专栏作为一个不必要的补充。</p><h2 id="参考资料不推荐"><a href="#参考资料不推荐" class="headerlink" title="参考资料不推荐"></a>参考资料不推荐</h2><ul><li>国内课本</li><li>谭浩强</li><li>代码字体非等宽的所有书</li></ul><h2 id="参考资料推荐"><a href="#参考资料推荐" class="headerlink" title="参考资料推荐"></a>参考资料推荐</h2><p>我倾向于推荐成体系化，但是篇幅比较精简的资料，不太推崇C Primer Plus那种事无巨细的书，很容易迷失方向。</p><ul><li><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++教程 - 菜鸟教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/114543112">C++自学精简教程 - Carea 知乎</a></li><li>Essential C++, Stanley B.Lippman</li></ul><p>慕课则推荐</p><ul><li><a href="https://www.icourse163.org/course/SEU-1003771004#/info">东南大学李骏扬老师的mooc</a>。</li></ul><p>学习C++务必要配套一定量的手敲代码环节，以下是一些可以提交代码并自动测试正确性的刷题平台，请同学们务必保证自己能够熟练地完成这些题目。</p><ul><li><a href="https://pintia.cn/problem-sets/14/exam/problems/type/6">基础编程题目集 - PTA</a></li></ul><p>友情推荐另一位助教，也是我的好朋友（杨哲睿）维护的教学资源网站。</p><ul><li><a href="https://adversarr.github.io/cpp-2022-lecture-notes/">算法与程序设计 2022</a></li></ul><p>如果你有志于在计算机专业道路上走得更远，你千万不能错过这篇指南。</p><ul><li><a href="https://csdiy.wiki/">CS自学指南</a></li></ul><hr><p>感谢阅读！<br>封面图来自Ask老师的微博。</p>]]></content>
    
    
    <categories>
      
      <category>C++助教问题汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++：关于文件I/O</title>
    <link href="/2021/08/07/c_cpp_about_file_io/"/>
    <url>/2021/08/07/c_cpp_about_file_io/</url>
    
    <content type="html"><![CDATA[<p>读写文件，控制台交互，这是C/C++永恒的主题之一。</p><span id="more"></span><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>每个人都知道至少一种输入、输出的编写方式。如果你是一个基础扎实的编码者，或许你知道两种甚至更多。这对于编写自己的程序似乎是远远足够了。</p><p>但在上周，在我查询关于如何在C/C++里实现<code>$ ls -a | grep txt</code>时，我遇到了一些挫折。如你所见，这里需要一些重定向和管道的知识。我查到了许多有效的代码案例，但让我困惑的是，它们的风格并不一致，有的使用了<code>fopen()</code>，有的使用了<code>dup()</code>，有的使用<code>printf()</code>，有的使用<code>write()</code>。我确信其中的相当一部分是可以彼此替代的，但却无从下手。</p><p>因此，我重新梳理了以下关于文件I/O的一些核心命题。你恐怕不会读到太多时髦的东西，但我相信这些知识能帮你更好地理解一些已经存在了很久的东西。</p><p>在下文，我试图回答以下几个问题：</p><ol><li>什么是文件描述符（为什么这个非负整数可以代表一个文件）</li><li>用文件描述符管理文件，和用文件指针有什么区别</li><li>什么是系统I/O和标准I/O（你用过<code>dup()</code>吗）</li><li>为什么不要混合使用系统I/O和标准I/O</li><li>缓冲区会搞出什么乱子（C/C++给我上的第一课：最简单的功能需要最深刻的理解）</li><li>标准输入/输出/错误是什么（是键盘输入、屏幕输出）</li><li>怎么在C/C++里面重定向标准流输入/输出（我知道，很多作业需要这个）</li></ol><p>现在，让我们从这一行代码开始吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br></code></pre></td></tr></table></figure><h2 id="打开文件表-open-file-table"><a href="#打开文件表-open-file-table" class="headerlink" title="打开文件表(open file table)"></a>打开文件表(open file table)</h2><p>为了理解文件描述符(file descriptor)的概念，让我们先回顾一下操作系统和文件系统(Virtual File System, VFS)的内容。</p><p><img src="/2021/08/07/c_cpp_about_file_io/1628407713527.png"></p><p>我们知道，文件存储在硬盘上。应用程序对文件访问时，先向内核提供文件的路径（如<code>/home/code/hello.c</code>)，然后由内核从根目录开始，一级一级解析路径、搜索目录，直到最终定位到文件，得到文件的相关信息，比如其存储与硬盘的何处。</p><p>遍历文件树的这个开销是不可忽略的，如果每一次读写文件都要从头找到它，也未免太过麻烦了。因此，linux等操作系统内核维护一个<strong>打开文件表</strong>(open-file-table)，这个列表里存放了所有目前打开的文件的信息，统一管理。</p><p>考虑到文件的访问者是进程，而多个进程可能同时对同一个文件进行不同位置的读写，打开文件表最终采用了<strong>两级内部表</strong>的设计。文件打开表分为了每个进程独有的一个<strong>进程表</strong>（用户打开文件表），和整个系统共用的一个<strong>系统表</strong>（系统打开文件表）。进程表的每个条目相应地指向系统表的条目，而系统表的条目再指向文件的具体位置。两级内部表使得多个进程打开同一个文件时，重叠部分不必反复存储，因而开销增长变得很小。</p><p>从进程的角度看，在显式地打开文件后，对文件进行读写操作时，直接通过自己进程表的索引(index)来指定文件。而进程表的索引，这个非负的整数，就是**文件描述符(file descriptor, fd)**。</p><p><img src="/2021/08/07/c_cpp_about_file_io/1628327993815.png"></p><p>读写一个文件所需要的信息被分级存储在了系统表和进程表条目上。系统表条目中，存储了与进程无关的信息，例如文件在磁盘上的位置、访问日期和文件大小等，并维护一个**打开计数(open count)**。而进程表条目中，存储了进程对文件的使用信息，如文件指针、访问权限等。</p><p>更具体而言，进程对文件的访问流程如下：</p><p><img src="/2021/08/07/c_cpp_about_file_io/1628328023076.png"></p><p>进程表条目、系统表条目、目录项和inode的概念概括如下：</p><ol><li><p><strong>进程表条目（文件描述符）</strong></p><p> 文件描述符是一个进程级的概念，因此，脱离进程去考虑它是无意义的。它的存在地位类似于一个文件指针<code>FILE *</code>，不同的文件描述符也可能指向同一个文件。</p></li><li><p><strong>系统表条目</strong></p><p> 系统表条目指示一个被打开的文件。它的数据结构里面存储了打开计数，也就是有多少个进程正打开了该文件。因此，系统表条目的存在说明该文件被至少一个进程打开，可能有读可能有写。它的里面直接存储inode的链接，而不存储目录下的链接，但inode的查找需要通过遍历目录项来得到。因此，对于已打开文件，其路径信息可以认为是被抹去的。</p></li><li><p><strong>目录项(dentry)</strong></p><p> 目录项是文件树的组成节点，所有路径查找都是通过目录项的逐级跳转实现的。其存有父子节点链接，文件名和inode链接等。解析路径查找文件的过程便是在目录项上逐级跳转，但在找到了文件之后，我们便不再关心它了。也就是说，文件的编辑和移动其实是分离的，你不能把移动文件视作某一种对文件内容的编辑。</p></li><li><p><strong>inode</strong></p><p> inode存储了字节数、UserID、GroupID、读写执行权限、时间戳等文件的元信息，和指向存有文件数据的block的链接。inode号码与文件名相分离，也就是说，inode不知情文件的路径、文件名等信息，不关心文件在文件树中的位置。不考虑硬链接的情况下，可以认为inode号就是文件的唯一标识。再四舍五入一下，可以近似认为inode就是文件本身（毕竟所有对文件的操作都绕不开inode）。</p></li></ol><h2 id="文件描述符-file-descriptor"><a href="#文件描述符-file-descriptor" class="headerlink" title="文件描述符(file descriptor)"></a>文件描述符(file descriptor)</h2><p>以上是操作系统层面对文件描述符的理解。但在实际应用中，我们更关心如何在软件开发层面理解它。</p><p>正如上文所说，在unix中，文件在进程中通常抽象化表示为一个文件描述符。</p><p>文件描述符是一个非零整数，用以标明每一个被进程所打开的文件。每次打开文件时，按照升序为其分配未被占用的非零整数。例如，第一个打开的文件分配为0，第二个分配为1，若为0的文件被关闭，则下一个打开的文件分配获得的文件描述符则为0。</p><ul><li>同一个进程内，不同的文件描述符也可能指向同一个文件</li><li>不同进程间，同一个文件描述符可能指向不同文件</li></ul><p>因为文件描述符是一个进程自己的进程表的序号，所以对于不同的进程，比较它们的文件描述符没有什么意义。但事实上，它们也可以跨进程地发挥用处，因为在进程<code>fork()</code>之后，子进程会复制父进程的进程表，父进程的文件描述符都会被继承，且指向相同的文件（系统表的相同位置）。这也称作父子进程间的文件共享。</p><p>而在同一个进程内，如果你多次打开同一个文件，那么你将得到多个不同的文件描述符，而它们指向同一个文件（系统表的相同位置）。不同的文件描述符之间不会彼此影响，哪怕它们事实上指向同一文件，你也需要将它们一一关闭，而不是关闭其中一个即可，即“内核的归内核管，程序员的归程序员管”。</p><p>总之，你其实不关心它们是否指向同一个文件。</p><p><a href="https://blog.csdn.net/test1280/article/details/80293294">C/C++：文件描述符与进程之间的关系</a></p><h2 id="标准I-O与系统I-O"><a href="#标准I-O与系统I-O" class="headerlink" title="标准I/O与系统I/O"></a>标准I/O与系统I/O</h2><p>对文件描述符的操作是管理文件的基本方式，但却不是我们熟悉的方式。任何一个学过C的人都不会对下面的代码感到陌生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br>    FILE *file = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;%s&quot;</span>, str);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>而对这种下面的这段代码，恐怕没有那么熟悉。（也有可能，你是一个酷爱管理所有底层细节的C语言专家）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>    write(fd, str, <span class="hljs-keyword">sizeof</span>(str));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（当我第一次看到<code>int fd</code>时，我确实被搞糊涂了，现在你可以知道它是一个文件描述符）</p><p>基于文件指针<code>FILE *</code>的I/O（或者标准I/O），实际上是C语言对基于文件描述符的I/O（或者系统I/O）的一层封装，用<code>fprintf()</code>、<code>fscanf()</code>等替代<code>read()</code>和<code>write()</code>。每个<code>FILE</code>对象中存储了一个文件描述符。二者之间可以进行自由的相互转换。大多数时候它们是一一对应的关系，只要你不捣乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 用两种不同的方式打开文件</span><br>    FILE *file1 = fopen(<span class="hljs-string">&quot;example-1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-type">int</span> fd2 = open(<span class="hljs-string">&quot;example-2.txt&quot;</span>, O_WRONLY | O_CREAT);<br>    <br>    <span class="hljs-comment">// 相互转换</span><br>    <span class="hljs-type">int</span> fd1 = fileon(file1);<br>    FILE *file2 = fdopen(fd2, <span class="hljs-string">&quot;w+&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>标准I/O和系统I/O都是对I/O的操作不同风格的管理，简要对比如下：</p><table><thead><tr><th></th><th>标准I/O</th><th>系统I/O</th></tr></thead><tbody><tr><td>头文件</td><td><code>stdio.h</code></td><td><code>io.h</code></td></tr><tr><td>文件表示</td><td><code>FILE *</code> (文件指针)</td><td><code>int</code> (文件描述符)</td></tr><tr><td>打开文件</td><td><code>fopen()</code></td><td><code>open()</code></td></tr><tr><td>关闭文件</td><td><code>fclose()</code></td><td><code>close()</code></td></tr><tr><td>常用写出</td><td><code>fprintf()</code></td><td><code>write()</code></td></tr><tr><td>常用读入</td><td><code>fscanf()</code></td><td><code>read()</code></td></tr><tr><td>标准输入</td><td><code>stdin</code></td><td><code>STDIN_FILENO</code> (即<code>0</code>)</td></tr><tr><td>标准输出</td><td><code>stdout</code></td><td><code>STDOUT_FILENO</code> (即<code>1</code>)</td></tr><tr><td>标准错误</td><td><code>stderr</code></td><td><code>STDOUT_FILENO</code> (即<code>2</code>)</td></tr><tr><td>特点</td><td>流处理，有缓冲区</td><td>更低级些</td></tr></tbody></table><p>标准I/O除了封装了各个数据类型与字符串之间的转换(也就是<code>%d</code>，<code>%f</code>那些），还使用了<strong>缓冲技术</strong>，当数据写入时并没有立即把数据交给内核，而是先存放在缓冲区(buffer)中，当缓冲区满时，会一次性把缓冲中的数据交给内核写到文件中，这样就减少内核态与用户态的切换次数。而系统I/O每写一次数据就要进入一次内核态，这样就浪费了大量时间进行内核态与用户态的切换，因此用时更长。</p><p><a href="https://www.cnblogs.com/joeblackzqq/archive/2011/04/11/2013010.html">open和fdopen的区别 清清飞扬</a></p><p>系统I/O则是操作系统双手的延申，可以实现字节级别的数据管理，即时性高，它比较适合底层开发。而缓冲区策略则更适合日常的应用场景。</p><h2 id="缓冲区的潜在问题"><a href="#缓冲区的潜在问题" class="headerlink" title="缓冲区的潜在问题"></a>缓冲区的潜在问题</h2><p>缓冲区的设计在大部分日常场景下都是高效的，但它存在一些潜在的问题。</p><p>缓冲区机制虽然试图表现得透明，然而它<strong>并不是透明的</strong>。就像缓存(cache)会因更新不及时导致读到的数据不符预期，缓冲不及时也会导致错误的（甚至是匪夷所思的）写出结果。</p><p>以下是一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *file = fopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;hello\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>1.out</code>中的输出如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">hello</span><br><br></code></pre></td></tr></table></figure><p>可以看到，我们的程序只进行了一次写，却产生了两份输出。究其原因，是因为程序在执行完第8行后，并没有真正把结果写入<code>1.out</code>中，而是将其放入了缓冲区，等进程结束时才统一写入。然而，<code>fork()</code>产生的子进程拷贝了父进程的缓冲区和文件描述符，因此，子进程和父进程结束时，分别进行了一次缓存更新，总共产生了两次写入。</p><p><a href="https://blog.csdn.net/amei113/article/details/84642479">标准输出缓存在多进程代码中引起的一个问题</a></p><p><a href="https://www.cnblogs.com/sir-jarvis/p/4075850.html">C标准I/O缓冲区：全缓冲和行缓冲</a></p><p>针对不同的场景，标准I/O预设了三种缓冲区，分别是全缓冲、行缓冲和无缓冲。</p><ul><li>全缓冲：仅当I/O缓冲区被填满，或者文件被关闭，或进程结束时，才刷新缓冲区，进行实际I/O操作。也可以执行<code>fflush()</code>手动刷新。读写一般文件默认为全缓冲。</li><li>行缓冲：标准输入、标准输出流都是采用行缓冲。也就是每次换行时进行实际I/O操作。</li><li>无缓存：标准错误流就是采用无缓冲。第一时间进行I/O。（正如系统I/O）</li></ul><p>它们具有不同的更新及时性。更新的越及时，I/O负担越大，有时是不必要的；而更新的越不及时，越有可能通过合并I/O提升效率，但有可能产生预期外的表现。当然，你也可以手动更改指定文件的缓冲区类型。</p><p>正是因为标准I/O对一般文件的读写默认为全缓冲，因此会出现这种情况：程序写入日志时，外部打开文件总是看不见更新，得等程序关闭该文件时，或者程序执行完毕时，才能拿到输出。</p><p>正如你所见，你应当对缓冲区问题保持一定的警惕。这可不是什么闭着眼睛用就能发挥奇效的东西，当问题发生时，你和计算机之间，总会有一个在自作聪明。</p><p>基于类似的理由，当你在混合使用<code>printf()</code>和<code>write()</code>时，二者的输出顺序与代码的执行顺序是否一致，会取决于你将其重定向至一个文件或是终端。这很有可能导致“bug仅出现于生产环境下”的欺骗性灾难。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;byebye\n&quot;</span>, <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./test<br>hello<br>byebye<br>$ ./test &gt; 1.out | <span class="hljs-built_in">cat</span> 1.out<br>byebye<br>hello<br></code></pre></td></tr></table></figure><p>我会向你展示更多例子，证明标准I/O和系统I/O的混合使用不会是一个好的主意。</p><h2 id="混合使用标准I-O与系统I-O的潜在问题"><a href="#混合使用标准I-O与系统I-O的潜在问题" class="headerlink" title="混合使用标准I/O与系统I/O的潜在问题"></a>混合使用标准I/O与系统I/O的潜在问题</h2><p>尽管文件描述符和文件指针之间可以进行自由的相互转换，也可以创建多个文件指针指向同一个文件描述符，将二者混合使用，不过很少这么做。</p><p>一方面是因为文件描述符在通过<code>open()</code>创建时已经制定了读写类型（只读、只写、可读写等），而在使用<code>fdopen()</code>转换时需要指定该文件指针的流形态(<code>mode</code>)，此形态必须和原先文件描述符的读写模式相同，否则将会转换失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 以只写模式打开</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>    <span class="hljs-comment">// 又转换为只读模式(无效, 返回NULL)</span><br>    FILE *file = fdopen(fd, <span class="hljs-string">&quot;r&quot;</span>);<br><br>    <span class="hljs-type">char</span> line[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot;%s&quot;</span>, line); <span class="hljs-comment">// error</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（还好，你至少能知道它失败了）</p><p>另一方面是因为，当多个文件指针指向同一个文件描述符时，调用了<code>fclose()</code>后，相应的文件描述符<code>fd</code>也会被关闭，导致其他文件指针无效。</p><p><a href="https://zhuanlan.zhihu.com/p/112549454">谨慎使用fdopen函数 赵俊民</a></p><p>如果需要多个文件指针指向同一个文件，且分别管理生命周期，正确的使用方式应该是：用<code>dup()</code>复制文件描述符，确保文件描述符和文件指针是<strong>一一对应</strong>的关系。</p><p>总之，应避免二者的混合使用。</p><blockquote><p>Note that mixing use of FILEs and raw file descriptors canproduce unexpected results and <strong>should generally be avoided</strong>.  (Forthe masochistic among you: POSIX.1, section 8.2.3, describes indetail how this interaction is supposed to work.)  A general ruleis that file descriptors are handled in the kernel, while stdiois just a library.  This means for example, that after anexec(3), the child inherits all open file descriptors, but allold streams have become inaccessible.</p><p><a href="https://www.man7.org/linux/man-pages/man3/stdin.3.html">stdin(3) — Linux manual page</a><br>来自Manual的警告</p></blockquote><h2 id="标准输入-stdin-，标准输出-stdout-，标准错误-stderr"><a href="#标准输入-stdin-，标准输出-stdout-，标准错误-stderr" class="headerlink" title="标准输入(stdin)，标准输出(stdout)，标准错误(stderr)"></a>标准输入(stdin)，标准输出(stdout)，标准错误(stderr)</h2><p>除了对硬盘里文件的读写，还有一种最常见的读写，便是与程序员通过终端(terminal)画面和键盘进行的交互。程序读取终端里键入的一行内容，作为输入，然后将各种信息打印到终端画面上，作为输出。这便是我们熟悉的标准输入、输出。</p><p><img src="/2021/08/07/c_cpp_about_file_io/1628407729122.png"></p><blockquote><p>在正常情况下，每个 UNIX 程序在启动时都会为其打开三个流，一个用于输入，一个用于输出，一个用于打印诊断或错误消息。这些通常附加到用户的终端），但可能会引用文件或其他设备，具体取决于父进程选择设置的内容。<br><a href="https://www.man7.org/linux/man-pages/man3/stdin.3.html">stdin(3) — Linux manual page</a></p></blockquote><p>也就是说，对于每个程序（进程），在开始运行时都获得了默认的的标准输入（0），标准输出（1），标准错误（2）的文件描述符。操作系统贴心地将标准输入、标准输出、标准错误被<strong>抽象成了文件</strong>，将标准输入、输出文件与终端界面、键盘相连接，使得程序员可以将对它们的读写等价地理解为对文件的读写。</p><table><thead><tr><th></th><th>标准I/O</th><th>系统I/O</th></tr></thead><tbody><tr><td>文件表示</td><td><code>FILE *</code> (文件指针)</td><td><code>int</code> (文件描述符)</td></tr><tr><td>标准输入</td><td><code>stdin</code></td><td><code>STDIN_FILENO</code> (即<code>0</code>)</td></tr><tr><td>标准输出</td><td><code>stdout</code></td><td><code>STDOUT_FILENO</code> (即<code>1</code>)</td></tr><tr><td>标准错误</td><td><code>stderr</code></td><td><code>STDOUT_FILENO</code> (即<code>2</code>)</td></tr></tbody></table><p>如果你觉得0，1，2在程序中看起来像一个幻数，可以使用<code>STDIN_FILENO</code>等宏定义来替代它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 等价</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;hello world!\n&quot;</span>);<br><span class="hljs-comment">// 等价</span><br>write(STDOUT_FILENO, <span class="hljs-string">&quot;hello world!\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>) - <span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello world!\n&quot;</span>, <span class="hljs-number">13</span>);<br></code></pre></td></tr></table></figure><p>子进程的标准输入、输出、错误的文件标识符和文件指针与一般文件一样，都继承自父进程。因此，对于被重定向的父进程，其产生的子进程也会被重定向至相同文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    freopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father: hello world!\n&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>); \\ 文件缓冲问题<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son: hello world!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上，我很好奇操作系统是如何将标准输入、输出文件与终端界面、键盘进行连接的。这似乎与tty有关，我对此不太了解。大致来说是，在Linux系统中，控制台终端有一些设备特殊文件与之相关联，名如tty0、tty1、tty2等，可以通过shell命令<code>tty</code>命令显示终端机连接标准输入设备的文件具体名称，例如<code>/dev/tty1</code>等。</p><p><a href="https://segmentfault.com/a/1190000009082089">Linux TTY/PTS概述</a></p><p><img src="/2021/08/07/c_cpp_about_file_io/1628328043767.gif"></p><p>c语言中，<code>int isatty(int fd)</code>可以检测文件描述符<code>fd</code>所指向的文件是否为一终端机，<code>char *ttyname(int fd)</code>则返回<code>fd</code>对应的终端机文件名称。<br>可以用这种方式检验标准流是否被重定向。例如，如果<code>isatty(STDOUT_FILENO) == 0</code>，那么当前标准输出流被重定向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %d, %s\n&quot;</span>, i, isatty(i), ttyname(i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>“标准”输入/输出的名称有许多种理解，在我看来，这个“标准”更多是“默认”的意思，它是每个进程默认具备的输入、输出方式，且默认指向了终端机上。如果是这样，我们也可以通过修改它来使得它看起来不再那么“标准”。</p><p>对终端的读写被抽象为了文件（tty文件），而0，1，2等标准输入输出的文件描述符又指向这些文件，因而构成了对终端的读写。然而，我们可以更改文件描述符的指向，让标准输入/输出不指向终端，而是某个文件，或者让其他文件描述符指向终端的输入、输出。</p><p>对标准输入/输出的重定向无异于对文件的重定向。</p><p>如果我们希望更改输入、输出的目标，对于我们可以控制的代码部分，将<code>printf()</code>全部替换成<code>fprintf()</code>就可以更改输入、输出流的指向文件（这太容易了）。然而，当我们需要执行其他程序，而这些程序又严格地使用标准输入输出时，就只能通过重定向的方式更改输入、输出的目标。具体而言，就是更改文件描述符<code>0</code>，<code>1</code>，<code>2</code>，或者是<code>stdin</code>，<code>stdout</code>，<code>stderr</code>所指向的文件。</p><p>就不罗嗦了，直接上代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -a &gt; 1.out<br></code></pre></td></tr></table></figure><h3 id="标准I-O风格"><a href="#标准I-O风格" class="headerlink" title="标准I/O风格"></a>标准I/O风格</h3><p>关闭<code>stdout</code>原先指向的文件(tty)，然后令<code>stdout</code>指向我们指定的文件。也可以用<code>freopen(&quot;1.out&quot;, &quot;w&quot;, stdout);</code>代替，这个操作OI选手应该不会陌生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> cmd[] = <span class="hljs-string">&quot;/usr/bin/ls&quot;</span>;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        fclose(<span class="hljs-built_in">stdout</span>);<br>        <span class="hljs-built_in">stdout</span> = fopen(<span class="hljs-string">&quot;1.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>        <br>        execv(cmd, argv);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="系统I-O风格"><a href="#系统I-O风格" class="headerlink" title="系统I/O风格"></a>系统I/O风格</h3><p>将文件描述符0，1，2所指向的文件进行替换，即可实现标准流重定向。<code>dup2(int oldfd, int newfd)</code>将关闭<code>newfd</code>原先指向的文件，并将其指向<code>oldfd</code>所指向的文件，实现定向的文件标识符复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> cmd[] = <span class="hljs-string">&quot;/usr/bin/ls&quot;</span>;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.out&quot;</span>, O_WRONLY | O_CREAT);<br>        dup2(fd, STDOUT_FILENO);<br>        <br>        execv(cmd, argv);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>希望对你有帮助！</p><p>下次写关于匿名管道。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
